---
title: Writing a v2 Cloud Foundry Service
---

**Note:** This v2 Services API is still in development. The API and this documentation is subject to change.

There are two versions of the Cloud Foundry Services API. This page documents v2. For information about v1 of the API see [Writing a v1 Cloud Foundry Service]().

## <a id='api-changes'></a>What's New in Services API v2 ##

The key changes in v2 of the Services API are:

* Terminology change --- In Cloud Foundry v2, what used to be called a service gateway is referred to as a service broker.
* Unidirectional RESTful HTTP messages --- Brokers can run standalone.
* Easier catalog management and orphan detection --- This functionality is improved, and moved from the broker to the Cloud Controller.
* Consistent naming --- API endpoints and fields are consistently named.
* Orphan avoidance --- Automatic cleanup prevention of orphans (Inconsistent instances between broker and CC)

## <a id='api-roadmap'></a>API Roadmap ##
Possible changes that may be made to v2 of the Services API (without change to the version number) that will not break client and server functionality include:

* New optional endpoints (or new HTTP methods to existing endpoints) can be added representing new concepts. This will enable support for features such as snapshots, backups, updating instances, and updating bindings.  It is expected that brokers will export some listings of their optional capabilities in the catalog.

* New fields may be added to existing request/response messages. These fields must be optional, and should be ignored by clients and servers that do not understand them.

## <a id='api-overview'></a>API Overview ##

The Cloud Foundry services API defines the contract between the Cloud Controller and the service broker. The broker is expected to implement several HTTP (or HTTPS) endpoints underneath a URI prefix. A single service can only be provided by a single broker URL, but horizontal scalability and load balancing allows for multiple redundant brokers. A broker can also offer multiple services.

<%= image_tag("../../../../images/v2services.png", :width =>"960", :height =>"720", :style => 'background-color:#fff') %>

## <a id='authentication'></a>Authentication ##

Cloud Controller (final release v145+) authenticates with the Broker using HTTP basic authentication (the `Authentication:` header) on every request, and will reject any broker registrations that do not contain a username and password. The broker is responsible for checking the username and password and returning a 403 Forbidden message if they are invalid. Cloud Controller supports connecting to a broker using SSL if additional security is desired.

## <a id='register'></a>Registering a Broker ##

(not part of Broker V2 API)
Before a broker can be used with Cloud Foundry, the operator must register the broker with Cloud Controller.  Broker authors do not have to know how to use or implement this API, as this functionality is built into the cf command-line-interface.  Because these APIs are actually part of CC + its front-end clients (such as CF), we’ve moved them into this document: Managing V2 Brokers with CC.

## <a id='catalog-mgmt'></a>Catalog Management ##

The first endpoint that a broker must implement is the service catalog. Cloud Controller will initially fetch this endpoint from all brokers and make adjustments to the user-facing service catalog stored in the Cloud Controller database. If the catalog fails to initially load or validate, Cloud Controller will not allow the operator to add the new broker, and should give a meaningful error message. Cloud Controller will also update the catalog whenever a broker is updated, so you can use `update-service-broker` with no changes to force a catalog refresh.

When Cloud Controller fetches a catalog from a broker, it will compare the `unique_id` for services and plans with what is in the  Cloud Controller database. If a service or plan in the broker catalog has a `unique_id` which is not present in the database, a new record will be added to the database. If services or plans in the database are found with `unique_id`s that match the broker catalog, Cloud Controller will update update the records to match the broker’s catalog.

If the database has plans which are not found in the broker catalog, and there are no associated service instances, Cloud Controller will remove these plans from the database. If there are provisioned instances, the plan will be marked “inactive” and will no longer be visible in the marketplace catalog or be provisionable. Cloud Controller will then delete services that do not have associated plans from the database.


`GET /v2/catalog`

<table>

<thead>
<tr>
  <th>Response field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>services*</td>
  <td>servicesg</td>
  <td>Schema of service objects defined below:</td>
</tr>
<tr>
  <td>id*</td>
  <td>string</td>
  <td>An identifier, unique within the broker, used to correlate this service in future requests to the catalog.</td>
</tr>
<tr>
  <td>name*</td>
  <td>string</td>
  <td>The CLI-friendly name of the service that will appear in the catalog</td>
</tr>
<tr>
  <td>description*</td>
  <td>string</td>
  <td>A short description of the service that will appear in the catalog</td>
</tr>
<tr>
  <td>bindable*</td>
  <td>boolean</td>
  <td>Whether the service can be bound to applications. Defaults to true.</td>
</tr>
<tr>
  <td>tags</td>
  <td>array-of-strings</td>
  <td>A list of permissions that the user would have to give the service, if they provision it. Currently the only permission with any meaning is `syslog_drain`.  See Loggregator documentation (TBD) for more information </td>
</tr>
<tr>
  <td>metadata</td>
  <td>object</td>
  <td>A list of metadata for a service offering.  See [Service Metadata]() for more information.</td>
</tr>
<tr>
  <td>requires</td>
  <td>array-of-strings</td>
  <td>A list of permissions that the user would have to give the service, if they provision it. Currently the only permission with any meaning is `syslog_drain`.  See loggregator docs for more info (TBD).</td>
</tr>
<tr>
  <td>plans*</td>
  <td>array-of-objects
</td>
  <td>A list of plans for this service, schema defined below:</td>
</tr>
<tr>
  <td>id*</td>
  <td>string</td>
  <td>An identifier, unique within the broker, used to correlate this plan in future requests to the catalog</td>
</tr>
<tr>
  <td>name*</td>
  <td>string</td>
  <td>The CLI-friendly name of the plan that will appear in the catalog</td>
</tr>
<tr>
  <td>description*</td>
  <td>string</td>
  <td>IA short description of the service that will appear in the catalog.</td>
</tr>
<tr>
  <td>metadata</td>
  <td>object</td>
  <td>A list of metadata for a service plan.  See metadata specs for more information.</td>
</tr>
</tbody>
</table>

**Example response**

<pre class="terminal">
{
  "services": [{
    "id": "service-guid-here",
    "name": "MySQL",
    "description": "A MySQL-compatible relational database",
    "plans": [{
      "id": "plan1-guid-here",
      "name": "small",
      "description": "A small shared database with 100mb storage quota and 10 connections"
    },{
      "id": "plan2-guid-here",
      "name": "large",
      "description": "A large dedicated database with 10GB storage quota, 512MB of RAM, and 100 connections"
    }]
  }]
}
</pre>

## <a id='provisioning'></a>Provisioning ##

When the broker receives a provision request from Cloud Controller, it should synchronously take whatever action is necessary to create a new service resource for the developer. What a provision means for different services can vary dramatically, but there are a few common actions that work for many services. Examples of what provision could mean, when applied to a MySQL service:

* The developer gets an empty dedicated mysqld process running on its own VM.
* The developer gets an empty dedicated mysqld process running in lightweight container on a shared VM
* The developer gets an empty dedicated mysqld process running on a shared VM
* The developer gets an empty dedicated database, on an existing shared running mysqld
* The developer gets a database with business schema already there
* The developer gets a copy of a full database (such as provisioning a QA database which is a copy of production)

For non-data services, provisioning could just mean getting an account on an existing system.

`PUT /v2/service_instances/:id`

**In this API, the `:id` of a service instance is provided by the Cloud Controller**. This ID will be used for future requests (bind and unprovision), so the broker must use it to correlate the resource it creates.

<table>
<thead>
<tr>
  <th>Request field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>service_id*</td>
  <td>string</td>
  <td>The ID of the service within the catalog above.  While not strictly necessary, some brokers might make use of this ID.</td>
</tr>
<tr>
  <td>plan_id*</td>
  <td>string</td>
  <td>The ID of the plan within the above service (from the catalog endpoint) that the user would like provisioned.  Because plans have identifiers unique to a broker, this is enough information to determine what to provision.</td>
</tr>
<tr>
  <td>organization_guid*</td>
  <td>string</td>
  <td>The CC GUID of the organization under which the service is to be provisioned.  Many brokers should not use this field, but it could be helpful in determining data placement or applying custom business rules.</td>
</tr>
<tr>
  <td>space_guid*</td>
  <td>string</td>
  <td>Similar to organization_guid, but for the space.</td>
</tr>
</tbody>
</table>

Brokers are expected to respond with `201 Created` with the response body from the table below. They can also return `409 Conflict` if there is already a provisioned resource at this URL. Since this endpoint cannot be used to update resource parameters, brokers must return 409 if a conflicting request is made. Ideally, a non-conflicting request (duplicate ID and params) would return 200, but brokers may simply return 409 for a duplicate ID.  If they respond with any other code, CC will assume that the provision request failed and inform the user.

<table>
<thead>
<tr>
  <th>Response field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>dashboard_url</td>
  <td>string</td>
  <td>The URL a web-based management UI for the service instance. This optional URL allows space developers to visit a friendly management console for this instance. The URL should contain enough information to identify the resource being accessed (9189kdfsk0vfnku in the example below), as well as potentially credentials to access that resource (access_token=3hjdsnqadw487232lp below). CC will sign this URL so that the management console can trust that a user should be able to see the details of this instance. For more information, see [Authenticating a service using the dashboard_url]().</td>
</tr>
</tboby>
</table>

**Example response**

<pre class="terminal">
{
 "dashboard_url": "http://mongomgmthost/databases/9189kdfsk0vfnku?access_token=3hjdsnqadw487232lp"
}
</pre>

## <a id='binding'></a>Binding ##

When the broker receives a bind request from CC, it should take whatever action is necessary to generate a way for an application to utilize the already-provisioned resource. Not all services have to be bindable, some derive all their value just from being provisioned. In order for “unbind” to be the most meaningful, applications should be issued different credentials when possible, allowing one bound application can have its access actually revoked without affecting the others. Bind can mean different things depending on the service, here are some examples for Mysql:

* New random user credentials are generated for the existing database
* A single set of credentials are returned for every bind to the same database

`PUT /v2/service_instances/:instance_id/service_bindings/:id`

In this API, the `:id` of a service binding is provided by the CC. And `:instance_id` is the ID from a previously provisioned service instance.  This ID will be used for future unbind requests, so the broker must use it to correlate the resource it creates.

<table>
<thead>
<tr>
  <th>Request Field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>service_id*</td>
  <td>string</td>
  <td>ID of the service from the catalog.  Not necessary, but the broker could make use of this to locate the resource in question.</td>
</tr>
<tr>
  <td>plan_id*</td>
  <td>string</td>
  <td>ID of the plan from the catalog.  Not necessary, but the broker could make use of this to locate the resource in question.</td>
</tr>
</tbody>
</table>

Brokers are expected to respond with `200 OK` or `201 Created` with the response body from the table below. They can also return 409 Conflict if there is already a binding at this URL. Since this endpoint cannot be used to update resources, brokers must return 409 if a non-identical request is made. If they respond with any other code, CC will assume that the binding request failed and inform the user.

<table>
<thead>
<tr>
  <th>Response Field</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>credentials*</td>
  <td>object</td>
  <td>A free-form hash of credentials that the bound application can use to gain access to the service. We encourage the use of a `uri` field when possible (such as `mysql://user:password@host:port/dbname`), but it’s often useful to provide individual credentials pieces such as hostname, port, username, and password.</td>
</tr>
<tr>
  <td>syslog_drain_url</td>
  <td>string</td>
  <td>A URL that CF should drain logs to for the bound application. Requires the syslog_drain permission to have logs automatically wired to applications.</td>
</tr>
</tbody>
</table>

**Example response**

<pre class="terminal">
	{
	  "credentials": {
	    "uri": "mysql://mysqluser:pass@mysqlhost:3306/dbname",
	    "username": "mysqluser",
	    "password": "pass",
	    "host": "mysqlhost",
	    "port": 3306,
	    "database": "dbname"
	  }
	}

</pre>
